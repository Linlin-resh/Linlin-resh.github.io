<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience | Notes on AI4Science &amp; Graph Theory</title>
<meta name="keywords" content="reading-notes, network-theory, network-resilience, robustness, failure-analysis">
<meta name="description" content="Study notes for Chapter 16 of Newman&#39;s &#39;Networks: An Introduction&#39; covering network robustness, resilience measures, and failure analysis">
<meta name="author" content="Linlin-resh">
<link rel="canonical" href="https://Linlin-resh.github.io/posts/reading-notes-newman-ch16/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://Linlin-resh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://Linlin-resh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Linlin-resh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://Linlin-resh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://Linlin-resh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://Linlin-resh.github.io/posts/reading-notes-newman-ch16/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://Linlin-resh.github.io/css/math-enhancement.css"><script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,
      packages: {'[+]': ['ams', 'newcommand', 'configmacros']}
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      ignoreHtmlClass: 'tex2jax_ignore',
      processHtmlClass: 'tex2jax_process'
    },
    loader: {
      load: ['[tex]/ams', '[tex]/newcommand', '[tex]/configmacros']
    }
  };
</script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300;400;500;600;700&family=Source+Serif+Pro:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<meta property="og:url" content="https://Linlin-resh.github.io/posts/reading-notes-newman-ch16/">
  <meta property="og:site_name" content="Notes on AI4Science & Graph Theory">
  <meta property="og:title" content="Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience">
  <meta property="og:description" content="Study notes for Chapter 16 of Newman&#39;s &#39;Networks: An Introduction&#39; covering network robustness, resilience measures, and failure analysis">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-29T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-08-29T00:00:00+00:00">
    <meta property="article:tag" content="Reading-Notes">
    <meta property="article:tag" content="Network-Theory">
    <meta property="article:tag" content="Network-Resilience">
    <meta property="article:tag" content="Robustness">
    <meta property="article:tag" content="Failure-Analysis">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience">
<meta name="twitter:description" content="Study notes for Chapter 16 of Newman&#39;s &#39;Networks: An Introduction&#39; covering network robustness, resilience measures, and failure analysis">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://Linlin-resh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Reading Notes: Newman's Networks Chapter 16 - Network Resilience",
      "item": "https://Linlin-resh.github.io/posts/reading-notes-newman-ch16/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reading Notes: Newman's Networks Chapter 16 - Network Resilience",
  "name": "Reading Notes: Newman\u0027s Networks Chapter 16 - Network Resilience",
  "description": "Study notes for Chapter 16 of Newman's 'Networks: An Introduction' covering network robustness, resilience measures, and failure analysis",
  "keywords": [
    "reading-notes", "network-theory", "network-resilience", "robustness", "failure-analysis"
  ],
  "articleBody": "Introduction Chapter 16 of Newman’s Networks: An Introduction explores network resilience - the ability of networks to maintain their functionality under stress, attacks, or failures. This chapter covers robustness measures, failure analysis, and strategies for enhancing network resilience.\n16.1 Robustness Measures Connectivity Robustness Robustness Function Robustness function: $$R(p) = \\frac{1}{n} \\sum_{i=1}^n \\frac{S_i(p)}{n}$$\nWhere:\n$p$: Fraction of nodes removed $S_i(p)$: Size of largest component after removing $i$ nodes $n$: Total number of nodes Properties:\n$R(0) = 1$: No nodes removed $R(1) = 0$: All nodes removed $R(p)$: Monotonic decreasing function Critical Threshold Critical threshold $p_c$: $$R(p_c) = \\frac{1}{2}$$\nInterpretation: Fraction of nodes that can be removed before network loses half its functionality\nMathematical condition: $$p_c = \\frac{1}{\\kappa - 1}$$\nWhere $\\kappa = \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle}$ is the degree ratio.\nEfficiency Robustness Network Efficiency Global efficiency: $$E = \\frac{1}{n(n-1)} \\sum_{i \\neq j} \\frac{1}{d_{ij}}$$\nWhere $d_{ij}$ is the shortest path length between nodes $i$ and $j$.\nLocal efficiency: $$E_{\\text{local}} = \\frac{1}{n} \\sum_{i} E_i$$\nWhere $E_i$ is the efficiency of the subgraph of neighbors of node $i$.\nEfficiency Robustness Efficiency robustness: $$R_E(p) = \\frac{E(p)}{E(0)}$$\nWhere $E(p)$ is the efficiency after removing fraction $p$ of nodes.\nProperties:\n$R_E(0) = 1$: No nodes removed $R_E(1) = 0$: All nodes removed $R_E(p)$: Monotonic decreasing function Spectral Robustness Algebraic Connectivity Algebraic connectivity $\\lambda_2$: $$\\lambda_2 = \\min_{x \\perp \\mathbf{1}} \\frac{x^T L x}{x^T x}$$\nWhere $L$ is the Laplacian matrix.\nProperties:\n$\\lambda_2 \u003e 0$: Network is connected $\\lambda_2 = 0$: Network is disconnected Higher $\\lambda_2$: More robust network Spectral Robustness Spectral robustness: $$R_{\\lambda}(p) = \\frac{\\lambda_2(p)}{\\lambda_2(0)}$$\nWhere $\\lambda_2(p)$ is the algebraic connectivity after removing fraction $p$ of nodes.\n16.2 Attack Strategies Random Attacks Random Node Removal Process: Remove nodes randomly with probability $p$\nRobustness: $R_{\\text{random}}(p) = 1 - p$\nCritical threshold: $p_c = 0.5$\nMathematical analysis: $$R_{\\text{random}}(p) = \\frac{1}{n} \\sum_{i=1}^n \\frac{S_i(p)}{n}$$\nWhere $S_i(p)$ is the size of largest component after removing $i$ nodes.\nRandom Edge Removal Process: Remove edges randomly with probability $p$\nRobustness: $R_{\\text{random}}(p) = 1 - p$\nCritical threshold: $p_c = 0.5$\nMathematical analysis: $$R_{\\text{random}}(p) = \\frac{1}{m} \\sum_{i=1}^m \\frac{S_i(p)}{m}$$\nWhere $S_i(p)$ is the size of largest component after removing $i$ edges.\nTargeted Attacks Degree-Based Attacks Process: Remove nodes with highest degree\nRobustness: $R_{\\text{targeted}}(p) \u003c R_{\\text{random}}(p)$\nCritical threshold: $p_c \u003c 0.5$\nMathematical analysis: $$R_{\\text{targeted}}(p) = \\frac{1}{n} \\sum_{i=1}^n \\frac{S_i(p)}{n}$$\nWhere $S_i(p)$ is the size of largest component after removing $i$ highest-degree nodes.\nBetweenness-Based Attacks Process: Remove nodes with highest betweenness centrality\nRobustness: $R_{\\text{targeted}}(p) \u003c R_{\\text{random}}(p)$\nCritical threshold: $p_c \u003c 0.5$\nMathematical analysis: $$R_{\\text{targeted}}(p) = \\frac{1}{n} \\sum_{i=1}^n \\frac{S_i(p)}{n}$$\nWhere $S_i(p)$ is the size of largest component after removing $i$ highest-betweenness nodes.\nCloseness-Based Attacks Process: Remove nodes with highest closeness centrality\nRobustness: $R_{\\text{targeted}}(p) \u003c R_{\\text{random}}(p)$\nCritical threshold: $p_c \u003c 0.5$\nMathematical analysis: $$R_{\\text{targeted}}(p) = \\frac{1}{n} \\sum_{i=1}^n \\frac{S_i(p)}{n}$$\nWhere $S_i(p)$ is the size of largest component after removing $i$ highest-closeness nodes.\nAdaptive Attacks Adaptive Degree-Based Attacks Process:\nRemove node with highest degree Recalculate degrees Repeat Robustness: $R_{\\text{adaptive}}(p) \u003c R_{\\text{targeted}}(p)$\nCritical threshold: $p_c \u003c 0.5$\nMathematical analysis: $$R_{\\text{adaptive}}(p) = \\frac{1}{n} \\sum_{i=1}^n \\frac{S_i(p)}{n}$$\nWhere $S_i(p)$ is the size of largest component after removing $i$ nodes adaptively.\nAdaptive Betweenness-Based Attacks Process:\nRemove node with highest betweenness Recalculate betweenness Repeat Robustness: $R_{\\text{adaptive}}(p) \u003c R_{\\text{targeted}}(p)$\nCritical threshold: $p_c \u003c 0.5$\nMathematical analysis: $$R_{\\text{adaptive}}(p) = \\frac{1}{n} \\sum_{i=1}^n \\frac{S_i(p)}{n}$$\nWhere $S_i(p)$ is the size of largest component after removing $i$ nodes adaptively.\n16.3 Failure Cascades Cascade Models Load Redistribution Model Model: When a node fails, its load is redistributed to neighbors\nLoad evolution: $$L_i(t+1) = L_i(t) + \\sum_{j \\in \\text{failed}} \\frac{L_j(t)}{|\\text{neighbors}(j)|}$$\nWhere:\n$L_i(t)$: Load of node $i$ at time $t$ $\\text{failed}$: Set of failed nodes $|\\text{neighbors}(j)|$: Number of neighbors of node $j$ Threshold Model Model: Node fails if its load exceeds threshold\nFailure condition: $$L_i(t) \u003e T_i$$\nWhere $T_i$ is the threshold of node $i$.\nCascade condition: $$\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} \u003e 2$$\nWhere $\\langle k^2 \\rangle$ and $\\langle k \\rangle$ are the second and first moments of the degree distribution.\nCascade Analysis Cascade Size Cascade size $S$: $$S = \\frac{1}{n} \\sum_{i=1}^n S_i$$\nWhere $S_i$ is the size of cascade starting from node $i$.\nExpected cascade size: $$\\langle S \\rangle = \\frac{1}{n} \\sum_{i=1}^n \\langle S_i \\rangle$$\nCascade Probability Cascade probability $P$: $$P = \\frac{1}{n} \\sum_{i=1}^n P_i$$\nWhere $P_i$ is the probability of cascade starting from node $i$.\nExpected cascade probability: $$\\langle P \\rangle = \\frac{1}{n} \\sum_{i=1}^n \\langle P_i \\rangle$$\n16.4 Resilience Enhancement Redundancy Edge Redundancy Edge redundancy: $$R_E = \\frac{m - m_{\\min}}{m_{\\min}}$$\nWhere:\n$m$: Number of edges $m_{\\min}$: Minimum number of edges for connectivity Properties:\n$R_E \\geq 0$: Always non-negative $R_E = 0$: No redundancy Higher $R_E$: More redundant network Node Redundancy Node redundancy: $$R_N = \\frac{n - n_{\\min}}{n_{\\min}}$$\nWhere:\n$n$: Number of nodes $n_{\\min}$: Minimum number of nodes for functionality Properties:\n$R_N \\geq 0$: Always non-negative $R_N = 0$: No redundancy Higher $R_N$: More redundant network Diversity Degree Diversity Degree diversity: $$D_k = \\frac{\\sigma_k}{\\langle k \\rangle}$$\nWhere:\n$\\sigma_k$: Standard deviation of degrees $\\langle k \\rangle$: Average degree Properties:\n$D_k \\geq 0$: Always non-negative $D_k = 0$: No diversity Higher $D_k$: More diverse network Path Diversity Path diversity: $$D_p = \\frac{1}{n(n-1)} \\sum_{i \\neq j} \\frac{\\sigma_{ij}}{\\langle d_{ij} \\rangle}$$\nWhere:\n$\\sigma_{ij}$: Standard deviation of path lengths between $i$ and $j$ $\\langle d_{ij} \\rangle$: Average path length between $i$ and $j$ Properties:\n$D_p \\geq 0$: Always non-negative $D_p = 0$: No diversity Higher $D_p$: More diverse network Modularity Modular Structure Modular structure: Network divided into modules with dense internal connections and sparse external connections\nModularity: $$Q = \\frac{1}{2m} \\sum_{ij} \\left[ A_{ij} - \\frac{k_i k_j}{2m} \\right] \\delta(c_i, c_j)$$\nWhere:\n$A_{ij}$: Adjacency matrix $k_i, k_j$: Degrees of nodes $i, j$ $c_i, c_j$: Community assignments $\\delta(c_i, c_j)$: Kronecker delta Properties:\n$Q \\in [-1, 1]$: Bounded $Q \u003e 0$: More modular than random $Q \u003c 0$: Less modular than random Resilience Benefits Modular networks:\nLocalized failures: Failures contained within modules Faster recovery: Modules can recover independently Reduced cascades: Failures less likely to spread 16.5 Applications to Materials Science Defect Networks Defect Tolerance Defect network robustness:\nRandom defects: Random node removal Clustered defects: Targeted node removal Critical defect concentration: $c_c = \\frac{1}{\\kappa - 1}$ Defect Clustering Defect clustering: $$C = \\frac{\\langle k^2 \\rangle - \\langle k \\rangle}{n \\langle k \\rangle^2}$$\nResilience benefits:\nLocalized damage: Clustered defects cause localized damage Faster healing: Defects can heal locally Reduced cascades: Defect propagation limited Nanowire Networks Electrical Robustness Electrical robustness: $$R_E = \\frac{\\sigma(p)}{\\sigma(0)}$$\nWhere $\\sigma(p)$ is the conductivity after removing fraction $p$ of nanowires.\nCritical threshold: $$p_c = \\frac{1}{\\kappa - 1}$$\nWhere $\\kappa = \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle}$.\nMechanical Robustness Mechanical robustness: $$R_M = \\frac{E(p)}{E(0)}$$\nWhere $E(p)$ is the Young’s modulus after removing fraction $p$ of nanowires.\nCritical threshold: $$p_c = \\frac{1}{\\kappa - 1}$$\nWhere $\\kappa = \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle}$.\nPhase Transitions Phase Stability Phase stability: $$S = \\frac{1}{n} \\sum_{i=1}^n S_i$$\nWhere $S_i$ is the stability of phase at node $i$.\nCritical temperature: $$T_c = \\frac{K \\langle k^2 \\rangle}{2 \\langle k \\rangle}$$\nWhere $K$ is the coupling strength.\nPhase Transition Robustness Phase transition robustness: $$R_P = \\frac{T_c(p)}{T_c(0)}$$\nWhere $T_c(p)$ is the critical temperature after removing fraction $p$ of nodes.\nCritical threshold: $$p_c = \\frac{1}{\\kappa - 1}$$\nWhere $\\kappa = \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle}$.\nCode Example: Network Resilience Analysis import networkx as nx import numpy as np import matplotlib.pyplot as plt from collections import defaultdict from scipy.sparse import csgraph from sklearn.metrics import pairwise_distances def calculate_robustness_measures(G): \"\"\"Calculate various robustness measures\"\"\" n = G.number_of_nodes() m = G.number_of_edges() # Connectivity robustness if nx.is_connected(G): connectivity_robustness = 1.0 else: # Calculate largest component size components = list(nx.connected_components(G)) largest_component = max(components, key=len) connectivity_robustness = len(largest_component) / n # Efficiency robustness if nx.is_connected(G): efficiency = nx.global_efficiency(G) else: # Calculate efficiency of largest component components = list(nx.connected_components(G)) largest_component = max(components, key=len) subgraph = G.subgraph(largest_component) efficiency = nx.global_efficiency(subgraph) # Spectral robustness L = nx.laplacian_matrix(G).toarray() eigenvals = np.linalg.eigvals(L) eigenvals = np.real(eigenvals) eigenvals = np.sort(eigenvals) algebraic_connectivity = eigenvals[1] if len(eigenvals) \u003e 1 else 0 # Redundancy measures edge_redundancy = (m - (n - 1)) / (n - 1) if n \u003e 1 else 0 node_redundancy = (n - 1) / 1 if n \u003e 1 else 0 # Diversity measures degrees = [G.degree(i) for i in G.nodes()] degree_diversity = np.std(degrees) / np.mean(degrees) if np.mean(degrees) \u003e 0 else 0 # Path diversity if nx.is_connected(G): path_lengths = dict(nx.all_pairs_shortest_path_length(G)) path_diversity = 0 count = 0 for i in G.nodes(): for j in G.nodes(): if i != j: paths = path_lengths[i][j] path_diversity += paths count += 1 path_diversity = path_diversity / count if count \u003e 0 else 0 else: path_diversity = 0 return { 'connectivity_robustness': connectivity_robustness, 'efficiency': efficiency, 'algebraic_connectivity': algebraic_connectivity, 'edge_redundancy': edge_redundancy, 'node_redundancy': node_redundancy, 'degree_diversity': degree_diversity, 'path_diversity': path_diversity } def simulate_random_attack(G, p_values): \"\"\"Simulate random attack on network\"\"\" n = G.number_of_nodes() results = [] for p in p_values: # Remove random nodes n_remove = int(p * n) nodes_to_remove = np.random.choice(list(G.nodes()), n_remove, replace=False) # Create attacked network G_attacked = G.copy() G_attacked.remove_nodes_from(nodes_to_remove) # Calculate robustness measures measures = calculate_robustness_measures(G_attacked) measures['p'] = p results.append(measures) return results def simulate_targeted_attack(G, p_values, attack_type='degree'): \"\"\"Simulate targeted attack on network\"\"\" n = G.number_of_nodes() results = [] for p in p_values: # Remove targeted nodes n_remove = int(p * n) if attack_type == 'degree': # Remove highest degree nodes degrees = [(i, G.degree(i)) for i in G.nodes()] degrees.sort(key=lambda x: x[1], reverse=True) nodes_to_remove = [i for i, _ in degrees[:n_remove]] elif attack_type == 'betweenness': # Remove highest betweenness nodes betweenness = nx.betweenness_centrality(G) nodes_to_remove = sorted(betweenness.keys(), key=lambda x: betweenness[x], reverse=True)[:n_remove] elif attack_type == 'closeness': # Remove highest closeness nodes closeness = nx.closeness_centrality(G) nodes_to_remove = sorted(closeness.keys(), key=lambda x: closeness[x], reverse=True)[:n_remove] else: # Random attack nodes_to_remove = np.random.choice(list(G.nodes()), n_remove, replace=False) # Create attacked network G_attacked = G.copy() G_attacked.remove_nodes_from(nodes_to_remove) # Calculate robustness measures measures = calculate_robustness_measures(G_attacked) measures['p'] = p measures['attack_type'] = attack_type results.append(measures) return results def simulate_cascade_failure(G, initial_failures, threshold_factor=1.5): \"\"\"Simulate cascade failure in network\"\"\" n = G.number_of_nodes() # Initialize loads loads = {i: G.degree(i) for i in G.nodes()} thresholds = {i: loads[i] * threshold_factor for i in G.nodes()} # Initial failures failed_nodes = set(initial_failures) active_nodes = set(G.nodes()) - failed_nodes # Simulate cascade cascade_size = len(failed_nodes) cascade_steps = 0 while True: new_failures = set() # Check each active node for node in active_nodes: if loads[node] \u003e thresholds[node]: new_failures.add(node) # If no new failures, cascade stops if not new_failures: break # Update failed nodes failed_nodes.update(new_failures) active_nodes -= new_failures # Redistribute loads for failed_node in new_failures: neighbors = list(G.neighbors(failed_node)) active_neighbors = [n for n in neighbors if n in active_nodes] if active_neighbors: load_per_neighbor = loads[failed_node] / len(active_neighbors) for neighbor in active_neighbors: loads[neighbor] += load_per_neighbor cascade_size = len(failed_nodes) cascade_steps += 1 # Prevent infinite loops if cascade_steps \u003e n: break return { 'cascade_size': cascade_size, 'cascade_steps': cascade_steps, 'final_failed_nodes': failed_nodes } def analyze_network_resilience(G): \"\"\"Comprehensive network resilience analysis\"\"\" # Calculate initial robustness measures initial_measures = calculate_robustness_measures(G) # Simulate different types of attacks p_values = np.linspace(0, 0.5, 20) random_results = simulate_random_attack(G, p_values) degree_results = simulate_targeted_attack(G, p_values, 'degree') betweenness_results = simulate_targeted_attack(G, p_values, 'betweenness') closeness_results = simulate_targeted_attack(G, p_values, 'closeness') # Simulate cascade failures cascade_results = [] for i in range(10): # Test 10 different initial failures initial_failures = np.random.choice(list(G.nodes()), 1, replace=False) cascade_result = simulate_cascade_failure(G, initial_failures) cascade_results.append(cascade_result) return { 'initial_measures': initial_measures, 'random_results': random_results, 'degree_results': degree_results, 'betweenness_results': betweenness_results, 'closeness_results': closeness_results, 'cascade_results': cascade_results } def plot_resilience_analysis(G, analysis_results): \"\"\"Plot network resilience analysis results\"\"\" fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12)) # Attack robustness comparison p_values = [r['p'] for r in analysis_results['random_results']] # Connectivity robustness random_connectivity = [r['connectivity_robustness'] for r in analysis_results['random_results']] degree_connectivity = [r['connectivity_robustness'] for r in analysis_results['degree_results']] betweenness_connectivity = [r['connectivity_robustness'] for r in analysis_results['betweenness_results']] closeness_connectivity = [r['connectivity_robustness'] for r in analysis_results['closeness_results']] ax1.plot(p_values, random_connectivity, 'b-', label='Random', linewidth=2) ax1.plot(p_values, degree_connectivity, 'r-', label='Degree', linewidth=2) ax1.plot(p_values, betweenness_connectivity, 'g-', label='Betweenness', linewidth=2) ax1.plot(p_values, closeness_connectivity, 'm-', label='Closeness', linewidth=2) ax1.set_xlabel('Fraction of Nodes Removed') ax1.set_ylabel('Connectivity Robustness') ax1.set_title('Attack Robustness Comparison') ax1.legend() ax1.grid(True, alpha=0.3) # Efficiency robustness random_efficiency = [r['efficiency'] for r in analysis_results['random_results']] degree_efficiency = [r['efficiency'] for r in analysis_results['degree_results']] betweenness_efficiency = [r['efficiency'] for r in analysis_results['betweenness_results']] closeness_efficiency = [r['efficiency'] for r in analysis_results['closeness_results']] ax2.plot(p_values, random_efficiency, 'b-', label='Random', linewidth=2) ax2.plot(p_values, degree_efficiency, 'r-', label='Degree', linewidth=2) ax2.plot(p_values, betweenness_efficiency, 'g-', label='Betweenness', linewidth=2) ax2.plot(p_values, closeness_efficiency, 'm-', label='Closeness', linewidth=2) ax2.set_xlabel('Fraction of Nodes Removed') ax2.set_ylabel('Network Efficiency') ax2.set_title('Efficiency Robustness Comparison') ax2.legend() ax2.grid(True, alpha=0.3) # Cascade failure analysis cascade_sizes = [r['cascade_size'] for r in analysis_results['cascade_results']] cascade_steps = [r['cascade_steps'] for r in analysis_results['cascade_results']] ax3.scatter(cascade_steps, cascade_sizes, alpha=0.7, s=100) ax3.set_xlabel('Cascade Steps') ax3.set_ylabel('Cascade Size') ax3.set_title('Cascade Failure Analysis') ax3.grid(True, alpha=0.3) # Network visualization with robustness measures pos = nx.spring_layout(G, k=1, iterations=50) # Color nodes by degree degrees = [G.degree(i) for i in G.nodes()] node_colors = degrees node_sizes = 100 + 50 * np.array(degrees) / np.max(degrees) nx.draw(G, pos, ax=ax4, node_color=node_colors, node_size=node_sizes, edge_color='gray', alpha=0.6, cmap='viridis') ax4.set_title('Network with Degree-based Coloring') ax4.axis('off') plt.tight_layout() plt.show() # Example: Network resilience analysis G = nx.barabasi_albert_graph(100, 3) # Analyze network resilience analysis_results = analyze_network_resilience(G) # Print initial measures print(\"Initial Network Robustness Measures:\") for measure, value in analysis_results['initial_measures'].items(): print(f\"{measure}: {value:.3f}\") # Print cascade analysis cascade_sizes = [r['cascade_size'] for r in analysis_results['cascade_results']] cascade_steps = [r['cascade_steps'] for r in analysis_results['cascade_results']] print(f\"\\nCascade Failure Analysis:\") print(f\"Average cascade size: {np.mean(cascade_sizes):.1f}\") print(f\"Average cascade steps: {np.mean(cascade_steps):.1f}\") # Plot results plot_resilience_analysis(G, analysis_results) Key Takeaways Robustness measures: Multiple ways to quantify network resilience Attack strategies: Random vs. targeted attacks have different effects Failure cascades: Understanding how failures propagate through networks Resilience enhancement: Strategies for improving network robustness Applications: Important for materials science and engineering Mathematical analysis: Rigorous theory for understanding resilience Practical implications: Design principles for robust networks References Newman, M. E. J. (2010). Networks: An Introduction. Oxford University Press. Albert, R., Jeong, H., \u0026 Barabási, A. L. (2000). Error and attack tolerance of complex networks. Nature, 406(6794), 378-382. Callaway, D. S., et al. (2000). Network robustness and fragility: percolation on random graphs. Physical Review Letters, 85(25), 5468. Holme, P., et al. (2002). Attack vulnerability of complex networks. Physical Review E, 65(5), 056109. Network resilience analysis provides crucial insights for understanding and improving the robustness of complex systems, with important applications in materials science and engineering.\n",
  "wordCount" : "2288",
  "inLanguage": "en",
  "datePublished": "2025-08-29T00:00:00Z",
  "dateModified": "2025-08-29T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Linlin-resh"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://Linlin-resh.github.io/posts/reading-notes-newman-ch16/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes on AI4Science \u0026 Graph Theory",
    "logo": {
      "@type": "ImageObject",
      "url": "https://Linlin-resh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Linlin-resh.github.io/" accesskey="h" title="Notes on AI4Science &amp; Graph Theory (Alt + H)">Notes on AI4Science &amp; Graph Theory</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://Linlin-resh.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://Linlin-resh.github.io/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://Linlin-resh.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://Linlin-resh.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://Linlin-resh.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience
    </h1>
    <div class="post-description">
      Study notes for Chapter 16 of Newman&#39;s &#39;Networks: An Introduction&#39; covering network robustness, resilience measures, and failure analysis
    </div>
    <div class="post-meta"><span title='2025-08-29 00:00:00 +0000 UTC'>August 29, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2288 words&nbsp;·&nbsp;Linlin-resh

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#161-robustness-measures" aria-label="16.1 Robustness Measures">16.1 Robustness Measures</a><ul>
                        
                <li>
                    <a href="#connectivity-robustness" aria-label="Connectivity Robustness">Connectivity Robustness</a><ul>
                        
                <li>
                    <a href="#robustness-function" aria-label="Robustness Function">Robustness Function</a></li>
                <li>
                    <a href="#critical-threshold" aria-label="Critical Threshold">Critical Threshold</a></li></ul>
                </li>
                <li>
                    <a href="#efficiency-robustness" aria-label="Efficiency Robustness">Efficiency Robustness</a><ul>
                        
                <li>
                    <a href="#network-efficiency" aria-label="Network Efficiency">Network Efficiency</a></li>
                <li>
                    <a href="#efficiency-robustness-1" aria-label="Efficiency Robustness">Efficiency Robustness</a></li></ul>
                </li>
                <li>
                    <a href="#spectral-robustness" aria-label="Spectral Robustness">Spectral Robustness</a><ul>
                        
                <li>
                    <a href="#algebraic-connectivity" aria-label="Algebraic Connectivity">Algebraic Connectivity</a></li>
                <li>
                    <a href="#spectral-robustness-1" aria-label="Spectral Robustness">Spectral Robustness</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#162-attack-strategies" aria-label="16.2 Attack Strategies">16.2 Attack Strategies</a><ul>
                        
                <li>
                    <a href="#random-attacks" aria-label="Random Attacks">Random Attacks</a><ul>
                        
                <li>
                    <a href="#random-node-removal" aria-label="Random Node Removal">Random Node Removal</a></li>
                <li>
                    <a href="#random-edge-removal" aria-label="Random Edge Removal">Random Edge Removal</a></li></ul>
                </li>
                <li>
                    <a href="#targeted-attacks" aria-label="Targeted Attacks">Targeted Attacks</a><ul>
                        
                <li>
                    <a href="#degree-based-attacks" aria-label="Degree-Based Attacks">Degree-Based Attacks</a></li>
                <li>
                    <a href="#betweenness-based-attacks" aria-label="Betweenness-Based Attacks">Betweenness-Based Attacks</a></li>
                <li>
                    <a href="#closeness-based-attacks" aria-label="Closeness-Based Attacks">Closeness-Based Attacks</a></li></ul>
                </li>
                <li>
                    <a href="#adaptive-attacks" aria-label="Adaptive Attacks">Adaptive Attacks</a><ul>
                        
                <li>
                    <a href="#adaptive-degree-based-attacks" aria-label="Adaptive Degree-Based Attacks">Adaptive Degree-Based Attacks</a></li>
                <li>
                    <a href="#adaptive-betweenness-based-attacks" aria-label="Adaptive Betweenness-Based Attacks">Adaptive Betweenness-Based Attacks</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#163-failure-cascades" aria-label="16.3 Failure Cascades">16.3 Failure Cascades</a><ul>
                        
                <li>
                    <a href="#cascade-models" aria-label="Cascade Models">Cascade Models</a><ul>
                        
                <li>
                    <a href="#load-redistribution-model" aria-label="Load Redistribution Model">Load Redistribution Model</a></li>
                <li>
                    <a href="#threshold-model" aria-label="Threshold Model">Threshold Model</a></li></ul>
                </li>
                <li>
                    <a href="#cascade-analysis" aria-label="Cascade Analysis">Cascade Analysis</a><ul>
                        
                <li>
                    <a href="#cascade-size" aria-label="Cascade Size">Cascade Size</a></li>
                <li>
                    <a href="#cascade-probability" aria-label="Cascade Probability">Cascade Probability</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#164-resilience-enhancement" aria-label="16.4 Resilience Enhancement">16.4 Resilience Enhancement</a><ul>
                        
                <li>
                    <a href="#redundancy" aria-label="Redundancy">Redundancy</a><ul>
                        
                <li>
                    <a href="#edge-redundancy" aria-label="Edge Redundancy">Edge Redundancy</a></li>
                <li>
                    <a href="#node-redundancy" aria-label="Node Redundancy">Node Redundancy</a></li></ul>
                </li>
                <li>
                    <a href="#diversity" aria-label="Diversity">Diversity</a><ul>
                        
                <li>
                    <a href="#degree-diversity" aria-label="Degree Diversity">Degree Diversity</a></li>
                <li>
                    <a href="#path-diversity" aria-label="Path Diversity">Path Diversity</a></li></ul>
                </li>
                <li>
                    <a href="#modularity" aria-label="Modularity">Modularity</a><ul>
                        
                <li>
                    <a href="#modular-structure" aria-label="Modular Structure">Modular Structure</a></li>
                <li>
                    <a href="#resilience-benefits" aria-label="Resilience Benefits">Resilience Benefits</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#165-applications-to-materials-science" aria-label="16.5 Applications to Materials Science">16.5 Applications to Materials Science</a><ul>
                        
                <li>
                    <a href="#defect-networks" aria-label="Defect Networks">Defect Networks</a><ul>
                        
                <li>
                    <a href="#defect-tolerance" aria-label="Defect Tolerance">Defect Tolerance</a></li>
                <li>
                    <a href="#defect-clustering" aria-label="Defect Clustering">Defect Clustering</a></li></ul>
                </li>
                <li>
                    <a href="#nanowire-networks" aria-label="Nanowire Networks">Nanowire Networks</a><ul>
                        
                <li>
                    <a href="#electrical-robustness" aria-label="Electrical Robustness">Electrical Robustness</a></li>
                <li>
                    <a href="#mechanical-robustness" aria-label="Mechanical Robustness">Mechanical Robustness</a></li></ul>
                </li>
                <li>
                    <a href="#phase-transitions" aria-label="Phase Transitions">Phase Transitions</a><ul>
                        
                <li>
                    <a href="#phase-stability" aria-label="Phase Stability">Phase Stability</a></li>
                <li>
                    <a href="#phase-transition-robustness" aria-label="Phase Transition Robustness">Phase Transition Robustness</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#code-example-network-resilience-analysis" aria-label="Code Example: Network Resilience Analysis">Code Example: Network Resilience Analysis</a></li>
                <li>
                    <a href="#key-takeaways" aria-label="Key Takeaways">Key Takeaways</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Chapter 16 of Newman&rsquo;s <em>Networks: An Introduction</em> explores <strong>network resilience</strong> - the ability of networks to maintain their functionality under stress, attacks, or failures. This chapter covers robustness measures, failure analysis, and strategies for enhancing network resilience.</p>
<h2 id="161-robustness-measures">16.1 Robustness Measures<a hidden class="anchor" aria-hidden="true" href="#161-robustness-measures">#</a></h2>
<h3 id="connectivity-robustness">Connectivity Robustness<a hidden class="anchor" aria-hidden="true" href="#connectivity-robustness">#</a></h3>
<h4 id="robustness-function">Robustness Function<a hidden class="anchor" aria-hidden="true" href="#robustness-function">#</a></h4>
<p><strong>Robustness function</strong>:
$$R(p) = \frac{1}{n} \sum_{i=1}^n \frac{S_i(p)}{n}$$</p>
<p>Where:</p>
<ul>
<li>$p$: Fraction of nodes removed</li>
<li>$S_i(p)$: Size of largest component after removing $i$ nodes</li>
<li>$n$: Total number of nodes</li>
</ul>
<p><strong>Properties</strong>:</p>
<ul>
<li>$R(0) = 1$: No nodes removed</li>
<li>$R(1) = 0$: All nodes removed</li>
<li>$R(p)$: Monotonic decreasing function</li>
</ul>
<h4 id="critical-threshold">Critical Threshold<a hidden class="anchor" aria-hidden="true" href="#critical-threshold">#</a></h4>
<p><strong>Critical threshold</strong> $p_c$:
$$R(p_c) = \frac{1}{2}$$</p>
<p><strong>Interpretation</strong>: Fraction of nodes that can be removed before network loses half its functionality</p>
<p><strong>Mathematical condition</strong>:
$$p_c = \frac{1}{\kappa - 1}$$</p>
<p>Where $\kappa = \frac{\langle k^2 \rangle}{\langle k \rangle}$ is the degree ratio.</p>
<h3 id="efficiency-robustness">Efficiency Robustness<a hidden class="anchor" aria-hidden="true" href="#efficiency-robustness">#</a></h3>
<h4 id="network-efficiency">Network Efficiency<a hidden class="anchor" aria-hidden="true" href="#network-efficiency">#</a></h4>
<p><strong>Global efficiency</strong>:
$$E = \frac{1}{n(n-1)} \sum_{i \neq j} \frac{1}{d_{ij}}$$</p>
<p>Where $d_{ij}$ is the shortest path length between nodes $i$ and $j$.</p>
<p><strong>Local efficiency</strong>:
$$E_{\text{local}} = \frac{1}{n} \sum_{i} E_i$$</p>
<p>Where $E_i$ is the efficiency of the subgraph of neighbors of node $i$.</p>
<h4 id="efficiency-robustness-1">Efficiency Robustness<a hidden class="anchor" aria-hidden="true" href="#efficiency-robustness-1">#</a></h4>
<p><strong>Efficiency robustness</strong>:
$$R_E(p) = \frac{E(p)}{E(0)}$$</p>
<p>Where $E(p)$ is the efficiency after removing fraction $p$ of nodes.</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>$R_E(0) = 1$: No nodes removed</li>
<li>$R_E(1) = 0$: All nodes removed</li>
<li>$R_E(p)$: Monotonic decreasing function</li>
</ul>
<h3 id="spectral-robustness">Spectral Robustness<a hidden class="anchor" aria-hidden="true" href="#spectral-robustness">#</a></h3>
<h4 id="algebraic-connectivity">Algebraic Connectivity<a hidden class="anchor" aria-hidden="true" href="#algebraic-connectivity">#</a></h4>
<p><strong>Algebraic connectivity</strong> $\lambda_2$:
$$\lambda_2 = \min_{x \perp \mathbf{1}} \frac{x^T L x}{x^T x}$$</p>
<p>Where $L$ is the Laplacian matrix.</p>
<p><strong>Properties</strong>:</p>
<ul>
<li>$\lambda_2 &gt; 0$: Network is connected</li>
<li>$\lambda_2 = 0$: Network is disconnected</li>
<li>Higher $\lambda_2$: More robust network</li>
</ul>
<h4 id="spectral-robustness-1">Spectral Robustness<a hidden class="anchor" aria-hidden="true" href="#spectral-robustness-1">#</a></h4>
<p><strong>Spectral robustness</strong>:
$$R_{\lambda}(p) = \frac{\lambda_2(p)}{\lambda_2(0)}$$</p>
<p>Where $\lambda_2(p)$ is the algebraic connectivity after removing fraction $p$ of nodes.</p>
<h2 id="162-attack-strategies">16.2 Attack Strategies<a hidden class="anchor" aria-hidden="true" href="#162-attack-strategies">#</a></h2>
<h3 id="random-attacks">Random Attacks<a hidden class="anchor" aria-hidden="true" href="#random-attacks">#</a></h3>
<h4 id="random-node-removal">Random Node Removal<a hidden class="anchor" aria-hidden="true" href="#random-node-removal">#</a></h4>
<p><strong>Process</strong>: Remove nodes randomly with probability $p$</p>
<p><strong>Robustness</strong>: $R_{\text{random}}(p) = 1 - p$</p>
<p><strong>Critical threshold</strong>: $p_c = 0.5$</p>
<p><strong>Mathematical analysis</strong>:
$$R_{\text{random}}(p) = \frac{1}{n} \sum_{i=1}^n \frac{S_i(p)}{n}$$</p>
<p>Where $S_i(p)$ is the size of largest component after removing $i$ nodes.</p>
<h4 id="random-edge-removal">Random Edge Removal<a hidden class="anchor" aria-hidden="true" href="#random-edge-removal">#</a></h4>
<p><strong>Process</strong>: Remove edges randomly with probability $p$</p>
<p><strong>Robustness</strong>: $R_{\text{random}}(p) = 1 - p$</p>
<p><strong>Critical threshold</strong>: $p_c = 0.5$</p>
<p><strong>Mathematical analysis</strong>:
$$R_{\text{random}}(p) = \frac{1}{m} \sum_{i=1}^m \frac{S_i(p)}{m}$$</p>
<p>Where $S_i(p)$ is the size of largest component after removing $i$ edges.</p>
<h3 id="targeted-attacks">Targeted Attacks<a hidden class="anchor" aria-hidden="true" href="#targeted-attacks">#</a></h3>
<h4 id="degree-based-attacks">Degree-Based Attacks<a hidden class="anchor" aria-hidden="true" href="#degree-based-attacks">#</a></h4>
<p><strong>Process</strong>: Remove nodes with highest degree</p>
<p><strong>Robustness</strong>: $R_{\text{targeted}}(p) &lt; R_{\text{random}}(p)$</p>
<p><strong>Critical threshold</strong>: $p_c &lt; 0.5$</p>
<p><strong>Mathematical analysis</strong>:
$$R_{\text{targeted}}(p) = \frac{1}{n} \sum_{i=1}^n \frac{S_i(p)}{n}$$</p>
<p>Where $S_i(p)$ is the size of largest component after removing $i$ highest-degree nodes.</p>
<h4 id="betweenness-based-attacks">Betweenness-Based Attacks<a hidden class="anchor" aria-hidden="true" href="#betweenness-based-attacks">#</a></h4>
<p><strong>Process</strong>: Remove nodes with highest betweenness centrality</p>
<p><strong>Robustness</strong>: $R_{\text{targeted}}(p) &lt; R_{\text{random}}(p)$</p>
<p><strong>Critical threshold</strong>: $p_c &lt; 0.5$</p>
<p><strong>Mathematical analysis</strong>:
$$R_{\text{targeted}}(p) = \frac{1}{n} \sum_{i=1}^n \frac{S_i(p)}{n}$$</p>
<p>Where $S_i(p)$ is the size of largest component after removing $i$ highest-betweenness nodes.</p>
<h4 id="closeness-based-attacks">Closeness-Based Attacks<a hidden class="anchor" aria-hidden="true" href="#closeness-based-attacks">#</a></h4>
<p><strong>Process</strong>: Remove nodes with highest closeness centrality</p>
<p><strong>Robustness</strong>: $R_{\text{targeted}}(p) &lt; R_{\text{random}}(p)$</p>
<p><strong>Critical threshold</strong>: $p_c &lt; 0.5$</p>
<p><strong>Mathematical analysis</strong>:
$$R_{\text{targeted}}(p) = \frac{1}{n} \sum_{i=1}^n \frac{S_i(p)}{n}$$</p>
<p>Where $S_i(p)$ is the size of largest component after removing $i$ highest-closeness nodes.</p>
<h3 id="adaptive-attacks">Adaptive Attacks<a hidden class="anchor" aria-hidden="true" href="#adaptive-attacks">#</a></h3>
<h4 id="adaptive-degree-based-attacks">Adaptive Degree-Based Attacks<a hidden class="anchor" aria-hidden="true" href="#adaptive-degree-based-attacks">#</a></h4>
<p><strong>Process</strong>:</p>
<ol>
<li>Remove node with highest degree</li>
<li>Recalculate degrees</li>
<li>Repeat</li>
</ol>
<p><strong>Robustness</strong>: $R_{\text{adaptive}}(p) &lt; R_{\text{targeted}}(p)$</p>
<p><strong>Critical threshold</strong>: $p_c &lt; 0.5$</p>
<p><strong>Mathematical analysis</strong>:
$$R_{\text{adaptive}}(p) = \frac{1}{n} \sum_{i=1}^n \frac{S_i(p)}{n}$$</p>
<p>Where $S_i(p)$ is the size of largest component after removing $i$ nodes adaptively.</p>
<h4 id="adaptive-betweenness-based-attacks">Adaptive Betweenness-Based Attacks<a hidden class="anchor" aria-hidden="true" href="#adaptive-betweenness-based-attacks">#</a></h4>
<p><strong>Process</strong>:</p>
<ol>
<li>Remove node with highest betweenness</li>
<li>Recalculate betweenness</li>
<li>Repeat</li>
</ol>
<p><strong>Robustness</strong>: $R_{\text{adaptive}}(p) &lt; R_{\text{targeted}}(p)$</p>
<p><strong>Critical threshold</strong>: $p_c &lt; 0.5$</p>
<p><strong>Mathematical analysis</strong>:
$$R_{\text{adaptive}}(p) = \frac{1}{n} \sum_{i=1}^n \frac{S_i(p)}{n}$$</p>
<p>Where $S_i(p)$ is the size of largest component after removing $i$ nodes adaptively.</p>
<h2 id="163-failure-cascades">16.3 Failure Cascades<a hidden class="anchor" aria-hidden="true" href="#163-failure-cascades">#</a></h2>
<h3 id="cascade-models">Cascade Models<a hidden class="anchor" aria-hidden="true" href="#cascade-models">#</a></h3>
<h4 id="load-redistribution-model">Load Redistribution Model<a hidden class="anchor" aria-hidden="true" href="#load-redistribution-model">#</a></h4>
<p><strong>Model</strong>: When a node fails, its load is redistributed to neighbors</p>
<p><strong>Load evolution</strong>:
$$L_i(t+1) = L_i(t) + \sum_{j \in \text{failed}} \frac{L_j(t)}{|\text{neighbors}(j)|}$$</p>
<p>Where:</p>
<ul>
<li>$L_i(t)$: Load of node $i$ at time $t$</li>
<li>$\text{failed}$: Set of failed nodes</li>
<li>$|\text{neighbors}(j)|$: Number of neighbors of node $j$</li>
</ul>
<h4 id="threshold-model">Threshold Model<a hidden class="anchor" aria-hidden="true" href="#threshold-model">#</a></h4>
<p><strong>Model</strong>: Node fails if its load exceeds threshold</p>
<p><strong>Failure condition</strong>:
$$L_i(t) &gt; T_i$$</p>
<p>Where $T_i$ is the threshold of node $i$.</p>
<p><strong>Cascade condition</strong>:
$$\frac{\langle k^2 \rangle}{\langle k \rangle} &gt; 2$$</p>
<p>Where $\langle k^2 \rangle$ and $\langle k \rangle$ are the second and first moments of the degree distribution.</p>
<h3 id="cascade-analysis">Cascade Analysis<a hidden class="anchor" aria-hidden="true" href="#cascade-analysis">#</a></h3>
<h4 id="cascade-size">Cascade Size<a hidden class="anchor" aria-hidden="true" href="#cascade-size">#</a></h4>
<p><strong>Cascade size</strong> $S$:
$$S = \frac{1}{n} \sum_{i=1}^n S_i$$</p>
<p>Where $S_i$ is the size of cascade starting from node $i$.</p>
<p><strong>Expected cascade size</strong>:
$$\langle S \rangle = \frac{1}{n} \sum_{i=1}^n \langle S_i \rangle$$</p>
<h4 id="cascade-probability">Cascade Probability<a hidden class="anchor" aria-hidden="true" href="#cascade-probability">#</a></h4>
<p><strong>Cascade probability</strong> $P$:
$$P = \frac{1}{n} \sum_{i=1}^n P_i$$</p>
<p>Where $P_i$ is the probability of cascade starting from node $i$.</p>
<p><strong>Expected cascade probability</strong>:
$$\langle P \rangle = \frac{1}{n} \sum_{i=1}^n \langle P_i \rangle$$</p>
<h2 id="164-resilience-enhancement">16.4 Resilience Enhancement<a hidden class="anchor" aria-hidden="true" href="#164-resilience-enhancement">#</a></h2>
<h3 id="redundancy">Redundancy<a hidden class="anchor" aria-hidden="true" href="#redundancy">#</a></h3>
<h4 id="edge-redundancy">Edge Redundancy<a hidden class="anchor" aria-hidden="true" href="#edge-redundancy">#</a></h4>
<p><strong>Edge redundancy</strong>:
$$R_E = \frac{m - m_{\min}}{m_{\min}}$$</p>
<p>Where:</p>
<ul>
<li>$m$: Number of edges</li>
<li>$m_{\min}$: Minimum number of edges for connectivity</li>
</ul>
<p><strong>Properties</strong>:</p>
<ul>
<li>$R_E \geq 0$: Always non-negative</li>
<li>$R_E = 0$: No redundancy</li>
<li>Higher $R_E$: More redundant network</li>
</ul>
<h4 id="node-redundancy">Node Redundancy<a hidden class="anchor" aria-hidden="true" href="#node-redundancy">#</a></h4>
<p><strong>Node redundancy</strong>:
$$R_N = \frac{n - n_{\min}}{n_{\min}}$$</p>
<p>Where:</p>
<ul>
<li>$n$: Number of nodes</li>
<li>$n_{\min}$: Minimum number of nodes for functionality</li>
</ul>
<p><strong>Properties</strong>:</p>
<ul>
<li>$R_N \geq 0$: Always non-negative</li>
<li>$R_N = 0$: No redundancy</li>
<li>Higher $R_N$: More redundant network</li>
</ul>
<h3 id="diversity">Diversity<a hidden class="anchor" aria-hidden="true" href="#diversity">#</a></h3>
<h4 id="degree-diversity">Degree Diversity<a hidden class="anchor" aria-hidden="true" href="#degree-diversity">#</a></h4>
<p><strong>Degree diversity</strong>:
$$D_k = \frac{\sigma_k}{\langle k \rangle}$$</p>
<p>Where:</p>
<ul>
<li>$\sigma_k$: Standard deviation of degrees</li>
<li>$\langle k \rangle$: Average degree</li>
</ul>
<p><strong>Properties</strong>:</p>
<ul>
<li>$D_k \geq 0$: Always non-negative</li>
<li>$D_k = 0$: No diversity</li>
<li>Higher $D_k$: More diverse network</li>
</ul>
<h4 id="path-diversity">Path Diversity<a hidden class="anchor" aria-hidden="true" href="#path-diversity">#</a></h4>
<p><strong>Path diversity</strong>:
$$D_p = \frac{1}{n(n-1)} \sum_{i \neq j} \frac{\sigma_{ij}}{\langle d_{ij} \rangle}$$</p>
<p>Where:</p>
<ul>
<li>$\sigma_{ij}$: Standard deviation of path lengths between $i$ and $j$</li>
<li>$\langle d_{ij} \rangle$: Average path length between $i$ and $j$</li>
</ul>
<p><strong>Properties</strong>:</p>
<ul>
<li>$D_p \geq 0$: Always non-negative</li>
<li>$D_p = 0$: No diversity</li>
<li>Higher $D_p$: More diverse network</li>
</ul>
<h3 id="modularity">Modularity<a hidden class="anchor" aria-hidden="true" href="#modularity">#</a></h3>
<h4 id="modular-structure">Modular Structure<a hidden class="anchor" aria-hidden="true" href="#modular-structure">#</a></h4>
<p><strong>Modular structure</strong>: Network divided into modules with dense internal connections and sparse external connections</p>
<p><strong>Modularity</strong>:
$$Q = \frac{1}{2m} \sum_{ij} \left[ A_{ij} - \frac{k_i k_j}{2m} \right] \delta(c_i, c_j)$$</p>
<p>Where:</p>
<ul>
<li>$A_{ij}$: Adjacency matrix</li>
<li>$k_i, k_j$: Degrees of nodes $i, j$</li>
<li>$c_i, c_j$: Community assignments</li>
<li>$\delta(c_i, c_j)$: Kronecker delta</li>
</ul>
<p><strong>Properties</strong>:</p>
<ul>
<li>$Q \in [-1, 1]$: Bounded</li>
<li>$Q &gt; 0$: More modular than random</li>
<li>$Q &lt; 0$: Less modular than random</li>
</ul>
<h4 id="resilience-benefits">Resilience Benefits<a hidden class="anchor" aria-hidden="true" href="#resilience-benefits">#</a></h4>
<p><strong>Modular networks</strong>:</p>
<ul>
<li><strong>Localized failures</strong>: Failures contained within modules</li>
<li><strong>Faster recovery</strong>: Modules can recover independently</li>
<li><strong>Reduced cascades</strong>: Failures less likely to spread</li>
</ul>
<h2 id="165-applications-to-materials-science">16.5 Applications to Materials Science<a hidden class="anchor" aria-hidden="true" href="#165-applications-to-materials-science">#</a></h2>
<h3 id="defect-networks">Defect Networks<a hidden class="anchor" aria-hidden="true" href="#defect-networks">#</a></h3>
<h4 id="defect-tolerance">Defect Tolerance<a hidden class="anchor" aria-hidden="true" href="#defect-tolerance">#</a></h4>
<p><strong>Defect network robustness</strong>:</p>
<ul>
<li><strong>Random defects</strong>: Random node removal</li>
<li><strong>Clustered defects</strong>: Targeted node removal</li>
<li><strong>Critical defect concentration</strong>: $c_c = \frac{1}{\kappa - 1}$</li>
</ul>
<h4 id="defect-clustering">Defect Clustering<a hidden class="anchor" aria-hidden="true" href="#defect-clustering">#</a></h4>
<p><strong>Defect clustering</strong>:
$$C = \frac{\langle k^2 \rangle - \langle k \rangle}{n \langle k \rangle^2}$$</p>
<p><strong>Resilience benefits</strong>:</p>
<ul>
<li><strong>Localized damage</strong>: Clustered defects cause localized damage</li>
<li><strong>Faster healing</strong>: Defects can heal locally</li>
<li><strong>Reduced cascades</strong>: Defect propagation limited</li>
</ul>
<h3 id="nanowire-networks">Nanowire Networks<a hidden class="anchor" aria-hidden="true" href="#nanowire-networks">#</a></h3>
<h4 id="electrical-robustness">Electrical Robustness<a hidden class="anchor" aria-hidden="true" href="#electrical-robustness">#</a></h4>
<p><strong>Electrical robustness</strong>:
$$R_E = \frac{\sigma(p)}{\sigma(0)}$$</p>
<p>Where $\sigma(p)$ is the conductivity after removing fraction $p$ of nanowires.</p>
<p><strong>Critical threshold</strong>:
$$p_c = \frac{1}{\kappa - 1}$$</p>
<p>Where $\kappa = \frac{\langle k^2 \rangle}{\langle k \rangle}$.</p>
<h4 id="mechanical-robustness">Mechanical Robustness<a hidden class="anchor" aria-hidden="true" href="#mechanical-robustness">#</a></h4>
<p><strong>Mechanical robustness</strong>:
$$R_M = \frac{E(p)}{E(0)}$$</p>
<p>Where $E(p)$ is the Young&rsquo;s modulus after removing fraction $p$ of nanowires.</p>
<p><strong>Critical threshold</strong>:
$$p_c = \frac{1}{\kappa - 1}$$</p>
<p>Where $\kappa = \frac{\langle k^2 \rangle}{\langle k \rangle}$.</p>
<h3 id="phase-transitions">Phase Transitions<a hidden class="anchor" aria-hidden="true" href="#phase-transitions">#</a></h3>
<h4 id="phase-stability">Phase Stability<a hidden class="anchor" aria-hidden="true" href="#phase-stability">#</a></h4>
<p><strong>Phase stability</strong>:
$$S = \frac{1}{n} \sum_{i=1}^n S_i$$</p>
<p>Where $S_i$ is the stability of phase at node $i$.</p>
<p><strong>Critical temperature</strong>:
$$T_c = \frac{K \langle k^2 \rangle}{2 \langle k \rangle}$$</p>
<p>Where $K$ is the coupling strength.</p>
<h4 id="phase-transition-robustness">Phase Transition Robustness<a hidden class="anchor" aria-hidden="true" href="#phase-transition-robustness">#</a></h4>
<p><strong>Phase transition robustness</strong>:
$$R_P = \frac{T_c(p)}{T_c(0)}$$</p>
<p>Where $T_c(p)$ is the critical temperature after removing fraction $p$ of nodes.</p>
<p><strong>Critical threshold</strong>:
$$p_c = \frac{1}{\kappa - 1}$$</p>
<p>Where $\kappa = \frac{\langle k^2 \rangle}{\langle k \rangle}$.</p>
<h2 id="code-example-network-resilience-analysis">Code Example: Network Resilience Analysis<a hidden class="anchor" aria-hidden="true" href="#code-example-network-resilience-analysis">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> networkx <span style="color:#ff79c6">as</span> nx
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> numpy <span style="color:#ff79c6">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> matplotlib.pyplot <span style="color:#ff79c6">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> collections <span style="color:#ff79c6">import</span> defaultdict
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> scipy.sparse <span style="color:#ff79c6">import</span> csgraph
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> sklearn.metrics <span style="color:#ff79c6">import</span> pairwise_distances
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">calculate_robustness_measures</span>(G):
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;&#34;&#34;Calculate various robustness measures&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>number_of_nodes()
</span></span><span style="display:flex;"><span>    m <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>number_of_edges()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Connectivity robustness</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> nx<span style="color:#ff79c6">.</span>is_connected(G):
</span></span><span style="display:flex;"><span>        connectivity_robustness <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">1.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Calculate largest component size</span>
</span></span><span style="display:flex;"><span>        components <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">list</span>(nx<span style="color:#ff79c6">.</span>connected_components(G))
</span></span><span style="display:flex;"><span>        largest_component <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">max</span>(components, key<span style="color:#ff79c6">=</span><span style="color:#8be9fd;font-style:italic">len</span>)
</span></span><span style="display:flex;"><span>        connectivity_robustness <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">len</span>(largest_component) <span style="color:#ff79c6">/</span> n
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Efficiency robustness</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> nx<span style="color:#ff79c6">.</span>is_connected(G):
</span></span><span style="display:flex;"><span>        efficiency <span style="color:#ff79c6">=</span> nx<span style="color:#ff79c6">.</span>global_efficiency(G)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Calculate efficiency of largest component</span>
</span></span><span style="display:flex;"><span>        components <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">list</span>(nx<span style="color:#ff79c6">.</span>connected_components(G))
</span></span><span style="display:flex;"><span>        largest_component <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">max</span>(components, key<span style="color:#ff79c6">=</span><span style="color:#8be9fd;font-style:italic">len</span>)
</span></span><span style="display:flex;"><span>        subgraph <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>subgraph(largest_component)
</span></span><span style="display:flex;"><span>        efficiency <span style="color:#ff79c6">=</span> nx<span style="color:#ff79c6">.</span>global_efficiency(subgraph)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Spectral robustness</span>
</span></span><span style="display:flex;"><span>    L <span style="color:#ff79c6">=</span> nx<span style="color:#ff79c6">.</span>laplacian_matrix(G)<span style="color:#ff79c6">.</span>toarray()
</span></span><span style="display:flex;"><span>    eigenvals <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>linalg<span style="color:#ff79c6">.</span>eigvals(L)
</span></span><span style="display:flex;"><span>    eigenvals <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>real(eigenvals)
</span></span><span style="display:flex;"><span>    eigenvals <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>sort(eigenvals)
</span></span><span style="display:flex;"><span>    algebraic_connectivity <span style="color:#ff79c6">=</span> eigenvals[<span style="color:#bd93f9">1</span>] <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">len</span>(eigenvals) <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">else</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Redundancy measures</span>
</span></span><span style="display:flex;"><span>    edge_redundancy <span style="color:#ff79c6">=</span> (m <span style="color:#ff79c6">-</span> (n <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>)) <span style="color:#ff79c6">/</span> (n <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">if</span> n <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">else</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    node_redundancy <span style="color:#ff79c6">=</span> (n <span style="color:#ff79c6">-</span> <span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">/</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">if</span> n <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">1</span> <span style="color:#ff79c6">else</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Diversity measures</span>
</span></span><span style="display:flex;"><span>    degrees <span style="color:#ff79c6">=</span> [G<span style="color:#ff79c6">.</span>degree(i) <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> G<span style="color:#ff79c6">.</span>nodes()]
</span></span><span style="display:flex;"><span>    degree_diversity <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>std(degrees) <span style="color:#ff79c6">/</span> np<span style="color:#ff79c6">.</span>mean(degrees) <span style="color:#ff79c6">if</span> np<span style="color:#ff79c6">.</span>mean(degrees) <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">else</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Path diversity</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">if</span> nx<span style="color:#ff79c6">.</span>is_connected(G):
</span></span><span style="display:flex;"><span>        path_lengths <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">dict</span>(nx<span style="color:#ff79c6">.</span>all_pairs_shortest_path_length(G))
</span></span><span style="display:flex;"><span>        path_diversity <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>        count <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> G<span style="color:#ff79c6">.</span>nodes():
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">for</span> j <span style="color:#ff79c6">in</span> G<span style="color:#ff79c6">.</span>nodes():
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> i <span style="color:#ff79c6">!=</span> j:
</span></span><span style="display:flex;"><span>                    paths <span style="color:#ff79c6">=</span> path_lengths[i][j]
</span></span><span style="display:flex;"><span>                    path_diversity <span style="color:#ff79c6">+=</span> paths
</span></span><span style="display:flex;"><span>                    count <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>        path_diversity <span style="color:#ff79c6">=</span> path_diversity <span style="color:#ff79c6">/</span> count <span style="color:#ff79c6">if</span> count <span style="color:#ff79c6">&gt;</span> <span style="color:#bd93f9">0</span> <span style="color:#ff79c6">else</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">else</span>:
</span></span><span style="display:flex;"><span>        path_diversity <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;connectivity_robustness&#39;</span>: connectivity_robustness,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;efficiency&#39;</span>: efficiency,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;algebraic_connectivity&#39;</span>: algebraic_connectivity,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;edge_redundancy&#39;</span>: edge_redundancy,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;node_redundancy&#39;</span>: node_redundancy,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;degree_diversity&#39;</span>: degree_diversity,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;path_diversity&#39;</span>: path_diversity
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">simulate_random_attack</span>(G, p_values):
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;&#34;&#34;Simulate random attack on network&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>number_of_nodes()
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">=</span> []
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> p <span style="color:#ff79c6">in</span> p_values:
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Remove random nodes</span>
</span></span><span style="display:flex;"><span>        n_remove <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">int</span>(p <span style="color:#ff79c6">*</span> n)
</span></span><span style="display:flex;"><span>        nodes_to_remove <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>random<span style="color:#ff79c6">.</span>choice(<span style="color:#8be9fd;font-style:italic">list</span>(G<span style="color:#ff79c6">.</span>nodes()), n_remove, replace<span style="color:#ff79c6">=</span><span style="color:#ff79c6">False</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Create attacked network</span>
</span></span><span style="display:flex;"><span>        G_attacked <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>copy()
</span></span><span style="display:flex;"><span>        G_attacked<span style="color:#ff79c6">.</span>remove_nodes_from(nodes_to_remove)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Calculate robustness measures</span>
</span></span><span style="display:flex;"><span>        measures <span style="color:#ff79c6">=</span> calculate_robustness_measures(G_attacked)
</span></span><span style="display:flex;"><span>        measures[<span style="color:#f1fa8c">&#39;p&#39;</span>] <span style="color:#ff79c6">=</span> p
</span></span><span style="display:flex;"><span>        results<span style="color:#ff79c6">.</span>append(measures)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> results
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">simulate_targeted_attack</span>(G, p_values, attack_type<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;degree&#39;</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;&#34;&#34;Simulate targeted attack on network&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>number_of_nodes()
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">=</span> []
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> p <span style="color:#ff79c6">in</span> p_values:
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Remove targeted nodes</span>
</span></span><span style="display:flex;"><span>        n_remove <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">int</span>(p <span style="color:#ff79c6">*</span> n)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> attack_type <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;degree&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4"># Remove highest degree nodes</span>
</span></span><span style="display:flex;"><span>            degrees <span style="color:#ff79c6">=</span> [(i, G<span style="color:#ff79c6">.</span>degree(i)) <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> G<span style="color:#ff79c6">.</span>nodes()]
</span></span><span style="display:flex;"><span>            degrees<span style="color:#ff79c6">.</span>sort(key<span style="color:#ff79c6">=</span><span style="color:#ff79c6">lambda</span> x: x[<span style="color:#bd93f9">1</span>], reverse<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>)
</span></span><span style="display:flex;"><span>            nodes_to_remove <span style="color:#ff79c6">=</span> [i <span style="color:#ff79c6">for</span> i, _ <span style="color:#ff79c6">in</span> degrees[:n_remove]]
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">elif</span> attack_type <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;betweenness&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4"># Remove highest betweenness nodes</span>
</span></span><span style="display:flex;"><span>            betweenness <span style="color:#ff79c6">=</span> nx<span style="color:#ff79c6">.</span>betweenness_centrality(G)
</span></span><span style="display:flex;"><span>            nodes_to_remove <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">sorted</span>(betweenness<span style="color:#ff79c6">.</span>keys(), key<span style="color:#ff79c6">=</span><span style="color:#ff79c6">lambda</span> x: betweenness[x], reverse<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>)[:n_remove]
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">elif</span> attack_type <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#39;closeness&#39;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4"># Remove highest closeness nodes</span>
</span></span><span style="display:flex;"><span>            closeness <span style="color:#ff79c6">=</span> nx<span style="color:#ff79c6">.</span>closeness_centrality(G)
</span></span><span style="display:flex;"><span>            nodes_to_remove <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">sorted</span>(closeness<span style="color:#ff79c6">.</span>keys(), key<span style="color:#ff79c6">=</span><span style="color:#ff79c6">lambda</span> x: closeness[x], reverse<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>)[:n_remove]
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4"># Random attack</span>
</span></span><span style="display:flex;"><span>            nodes_to_remove <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>random<span style="color:#ff79c6">.</span>choice(<span style="color:#8be9fd;font-style:italic">list</span>(G<span style="color:#ff79c6">.</span>nodes()), n_remove, replace<span style="color:#ff79c6">=</span><span style="color:#ff79c6">False</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Create attacked network</span>
</span></span><span style="display:flex;"><span>        G_attacked <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>copy()
</span></span><span style="display:flex;"><span>        G_attacked<span style="color:#ff79c6">.</span>remove_nodes_from(nodes_to_remove)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Calculate robustness measures</span>
</span></span><span style="display:flex;"><span>        measures <span style="color:#ff79c6">=</span> calculate_robustness_measures(G_attacked)
</span></span><span style="display:flex;"><span>        measures[<span style="color:#f1fa8c">&#39;p&#39;</span>] <span style="color:#ff79c6">=</span> p
</span></span><span style="display:flex;"><span>        measures[<span style="color:#f1fa8c">&#39;attack_type&#39;</span>] <span style="color:#ff79c6">=</span> attack_type
</span></span><span style="display:flex;"><span>        results<span style="color:#ff79c6">.</span>append(measures)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> results
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">simulate_cascade_failure</span>(G, initial_failures, threshold_factor<span style="color:#ff79c6">=</span><span style="color:#bd93f9">1.5</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;&#34;&#34;Simulate cascade failure in network&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    n <span style="color:#ff79c6">=</span> G<span style="color:#ff79c6">.</span>number_of_nodes()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Initialize loads</span>
</span></span><span style="display:flex;"><span>    loads <span style="color:#ff79c6">=</span> {i: G<span style="color:#ff79c6">.</span>degree(i) <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> G<span style="color:#ff79c6">.</span>nodes()}
</span></span><span style="display:flex;"><span>    thresholds <span style="color:#ff79c6">=</span> {i: loads[i] <span style="color:#ff79c6">*</span> threshold_factor <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> G<span style="color:#ff79c6">.</span>nodes()}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Initial failures</span>
</span></span><span style="display:flex;"><span>    failed_nodes <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">set</span>(initial_failures)
</span></span><span style="display:flex;"><span>    active_nodes <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">set</span>(G<span style="color:#ff79c6">.</span>nodes()) <span style="color:#ff79c6">-</span> failed_nodes
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Simulate cascade</span>
</span></span><span style="display:flex;"><span>    cascade_size <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">len</span>(failed_nodes)
</span></span><span style="display:flex;"><span>    cascade_steps <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>:
</span></span><span style="display:flex;"><span>        new_failures <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">set</span>()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Check each active node</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> node <span style="color:#ff79c6">in</span> active_nodes:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> loads[node] <span style="color:#ff79c6">&gt;</span> thresholds[node]:
</span></span><span style="display:flex;"><span>                new_failures<span style="color:#ff79c6">.</span>add(node)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># If no new failures, cascade stops</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">not</span> new_failures:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Update failed nodes</span>
</span></span><span style="display:flex;"><span>        failed_nodes<span style="color:#ff79c6">.</span>update(new_failures)
</span></span><span style="display:flex;"><span>        active_nodes <span style="color:#ff79c6">-=</span> new_failures
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Redistribute loads</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> failed_node <span style="color:#ff79c6">in</span> new_failures:
</span></span><span style="display:flex;"><span>            neighbors <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">list</span>(G<span style="color:#ff79c6">.</span>neighbors(failed_node))
</span></span><span style="display:flex;"><span>            active_neighbors <span style="color:#ff79c6">=</span> [n <span style="color:#ff79c6">for</span> n <span style="color:#ff79c6">in</span> neighbors <span style="color:#ff79c6">if</span> n <span style="color:#ff79c6">in</span> active_nodes]
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> active_neighbors:
</span></span><span style="display:flex;"><span>                load_per_neighbor <span style="color:#ff79c6">=</span> loads[failed_node] <span style="color:#ff79c6">/</span> <span style="color:#8be9fd;font-style:italic">len</span>(active_neighbors)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">for</span> neighbor <span style="color:#ff79c6">in</span> active_neighbors:
</span></span><span style="display:flex;"><span>                    loads[neighbor] <span style="color:#ff79c6">+=</span> load_per_neighbor
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        cascade_size <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">len</span>(failed_nodes)
</span></span><span style="display:flex;"><span>        cascade_steps <span style="color:#ff79c6">+=</span> <span style="color:#bd93f9">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># Prevent infinite loops</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> cascade_steps <span style="color:#ff79c6">&gt;</span> n:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">break</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;cascade_size&#39;</span>: cascade_size,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;cascade_steps&#39;</span>: cascade_steps,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;final_failed_nodes&#39;</span>: failed_nodes
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">analyze_network_resilience</span>(G):
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;&#34;&#34;Comprehensive network resilience analysis&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Calculate initial robustness measures</span>
</span></span><span style="display:flex;"><span>    initial_measures <span style="color:#ff79c6">=</span> calculate_robustness_measures(G)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Simulate different types of attacks</span>
</span></span><span style="display:flex;"><span>    p_values <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>linspace(<span style="color:#bd93f9">0</span>, <span style="color:#bd93f9">0.5</span>, <span style="color:#bd93f9">20</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    random_results <span style="color:#ff79c6">=</span> simulate_random_attack(G, p_values)
</span></span><span style="display:flex;"><span>    degree_results <span style="color:#ff79c6">=</span> simulate_targeted_attack(G, p_values, <span style="color:#f1fa8c">&#39;degree&#39;</span>)
</span></span><span style="display:flex;"><span>    betweenness_results <span style="color:#ff79c6">=</span> simulate_targeted_attack(G, p_values, <span style="color:#f1fa8c">&#39;betweenness&#39;</span>)
</span></span><span style="display:flex;"><span>    closeness_results <span style="color:#ff79c6">=</span> simulate_targeted_attack(G, p_values, <span style="color:#f1fa8c">&#39;closeness&#39;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Simulate cascade failures</span>
</span></span><span style="display:flex;"><span>    cascade_results <span style="color:#ff79c6">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">10</span>):  <span style="color:#6272a4"># Test 10 different initial failures</span>
</span></span><span style="display:flex;"><span>        initial_failures <span style="color:#ff79c6">=</span> np<span style="color:#ff79c6">.</span>random<span style="color:#ff79c6">.</span>choice(<span style="color:#8be9fd;font-style:italic">list</span>(G<span style="color:#ff79c6">.</span>nodes()), <span style="color:#bd93f9">1</span>, replace<span style="color:#ff79c6">=</span><span style="color:#ff79c6">False</span>)
</span></span><span style="display:flex;"><span>        cascade_result <span style="color:#ff79c6">=</span> simulate_cascade_failure(G, initial_failures)
</span></span><span style="display:flex;"><span>        cascade_results<span style="color:#ff79c6">.</span>append(cascade_result)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;initial_measures&#39;</span>: initial_measures,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;random_results&#39;</span>: random_results,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;degree_results&#39;</span>: degree_results,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;betweenness_results&#39;</span>: betweenness_results,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;closeness_results&#39;</span>: closeness_results,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#39;cascade_results&#39;</span>: cascade_results
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">plot_resilience_analysis</span>(G, analysis_results):
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;&#34;&#34;Plot network resilience analysis results&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    fig, ((ax1, ax2), (ax3, ax4)) <span style="color:#ff79c6">=</span> plt<span style="color:#ff79c6">.</span>subplots(<span style="color:#bd93f9">2</span>, <span style="color:#bd93f9">2</span>, figsize<span style="color:#ff79c6">=</span>(<span style="color:#bd93f9">15</span>, <span style="color:#bd93f9">12</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Attack robustness comparison</span>
</span></span><span style="display:flex;"><span>    p_values <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;p&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;random_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Connectivity robustness</span>
</span></span><span style="display:flex;"><span>    random_connectivity <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;connectivity_robustness&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;random_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    degree_connectivity <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;connectivity_robustness&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;degree_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    betweenness_connectivity <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;connectivity_robustness&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;betweenness_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    closeness_connectivity <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;connectivity_robustness&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;closeness_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>plot(p_values, random_connectivity, <span style="color:#f1fa8c">&#39;b-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Random&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>plot(p_values, degree_connectivity, <span style="color:#f1fa8c">&#39;r-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Degree&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>plot(p_values, betweenness_connectivity, <span style="color:#f1fa8c">&#39;g-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Betweenness&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>plot(p_values, closeness_connectivity, <span style="color:#f1fa8c">&#39;m-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Closeness&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>set_xlabel(<span style="color:#f1fa8c">&#39;Fraction of Nodes Removed&#39;</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>set_ylabel(<span style="color:#f1fa8c">&#39;Connectivity Robustness&#39;</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>set_title(<span style="color:#f1fa8c">&#39;Attack Robustness Comparison&#39;</span>)
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>legend()
</span></span><span style="display:flex;"><span>    ax1<span style="color:#ff79c6">.</span>grid(<span style="color:#ff79c6">True</span>, alpha<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0.3</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Efficiency robustness</span>
</span></span><span style="display:flex;"><span>    random_efficiency <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;efficiency&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;random_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    degree_efficiency <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;efficiency&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;degree_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    betweenness_efficiency <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;efficiency&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;betweenness_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    closeness_efficiency <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;efficiency&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;closeness_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>plot(p_values, random_efficiency, <span style="color:#f1fa8c">&#39;b-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Random&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>plot(p_values, degree_efficiency, <span style="color:#f1fa8c">&#39;r-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Degree&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>plot(p_values, betweenness_efficiency, <span style="color:#f1fa8c">&#39;g-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Betweenness&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>plot(p_values, closeness_efficiency, <span style="color:#f1fa8c">&#39;m-&#39;</span>, label<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;Closeness&#39;</span>, linewidth<span style="color:#ff79c6">=</span><span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>set_xlabel(<span style="color:#f1fa8c">&#39;Fraction of Nodes Removed&#39;</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>set_ylabel(<span style="color:#f1fa8c">&#39;Network Efficiency&#39;</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>set_title(<span style="color:#f1fa8c">&#39;Efficiency Robustness Comparison&#39;</span>)
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>legend()
</span></span><span style="display:flex;"><span>    ax2<span style="color:#ff79c6">.</span>grid(<span style="color:#ff79c6">True</span>, alpha<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0.3</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Cascade failure analysis</span>
</span></span><span style="display:flex;"><span>    cascade_sizes <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;cascade_size&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;cascade_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    cascade_steps <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;cascade_steps&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;cascade_results&#39;</span>]]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ax3<span style="color:#ff79c6">.</span>scatter(cascade_steps, cascade_sizes, alpha<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0.7</span>, s<span style="color:#ff79c6">=</span><span style="color:#bd93f9">100</span>)
</span></span><span style="display:flex;"><span>    ax3<span style="color:#ff79c6">.</span>set_xlabel(<span style="color:#f1fa8c">&#39;Cascade Steps&#39;</span>)
</span></span><span style="display:flex;"><span>    ax3<span style="color:#ff79c6">.</span>set_ylabel(<span style="color:#f1fa8c">&#39;Cascade Size&#39;</span>)
</span></span><span style="display:flex;"><span>    ax3<span style="color:#ff79c6">.</span>set_title(<span style="color:#f1fa8c">&#39;Cascade Failure Analysis&#39;</span>)
</span></span><span style="display:flex;"><span>    ax3<span style="color:#ff79c6">.</span>grid(<span style="color:#ff79c6">True</span>, alpha<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0.3</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Network visualization with robustness measures</span>
</span></span><span style="display:flex;"><span>    pos <span style="color:#ff79c6">=</span> nx<span style="color:#ff79c6">.</span>spring_layout(G, k<span style="color:#ff79c6">=</span><span style="color:#bd93f9">1</span>, iterations<span style="color:#ff79c6">=</span><span style="color:#bd93f9">50</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Color nodes by degree</span>
</span></span><span style="display:flex;"><span>    degrees <span style="color:#ff79c6">=</span> [G<span style="color:#ff79c6">.</span>degree(i) <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> G<span style="color:#ff79c6">.</span>nodes()]
</span></span><span style="display:flex;"><span>    node_colors <span style="color:#ff79c6">=</span> degrees
</span></span><span style="display:flex;"><span>    node_sizes <span style="color:#ff79c6">=</span> <span style="color:#bd93f9">100</span> <span style="color:#ff79c6">+</span> <span style="color:#bd93f9">50</span> <span style="color:#ff79c6">*</span> np<span style="color:#ff79c6">.</span>array(degrees) <span style="color:#ff79c6">/</span> np<span style="color:#ff79c6">.</span>max(degrees)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    nx<span style="color:#ff79c6">.</span>draw(G, pos, ax<span style="color:#ff79c6">=</span>ax4, node_color<span style="color:#ff79c6">=</span>node_colors, node_size<span style="color:#ff79c6">=</span>node_sizes,
</span></span><span style="display:flex;"><span>            edge_color<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;gray&#39;</span>, alpha<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0.6</span>, cmap<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#39;viridis&#39;</span>)
</span></span><span style="display:flex;"><span>    ax4<span style="color:#ff79c6">.</span>set_title(<span style="color:#f1fa8c">&#39;Network with Degree-based Coloring&#39;</span>)
</span></span><span style="display:flex;"><span>    ax4<span style="color:#ff79c6">.</span>axis(<span style="color:#f1fa8c">&#39;off&#39;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    plt<span style="color:#ff79c6">.</span>tight_layout()
</span></span><span style="display:flex;"><span>    plt<span style="color:#ff79c6">.</span>show()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Example: Network resilience analysis</span>
</span></span><span style="display:flex;"><span>G <span style="color:#ff79c6">=</span> nx<span style="color:#ff79c6">.</span>barabasi_albert_graph(<span style="color:#bd93f9">100</span>, <span style="color:#bd93f9">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Analyze network resilience</span>
</span></span><span style="display:flex;"><span>analysis_results <span style="color:#ff79c6">=</span> analyze_network_resilience(G)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Print initial measures</span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;Initial Network Robustness Measures:&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> measure, value <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;initial_measures&#39;</span>]<span style="color:#ff79c6">.</span>items():
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>measure<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">: </span><span style="color:#f1fa8c">{</span>value<span style="color:#f1fa8c">:</span><span style="color:#f1fa8c">.3f</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Print cascade analysis</span>
</span></span><span style="display:flex;"><span>cascade_sizes <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;cascade_size&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;cascade_results&#39;</span>]]
</span></span><span style="display:flex;"><span>cascade_steps <span style="color:#ff79c6">=</span> [r[<span style="color:#f1fa8c">&#39;cascade_steps&#39;</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> analysis_results[<span style="color:#f1fa8c">&#39;cascade_results&#39;</span>]]
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">\n</span><span style="color:#f1fa8c">Cascade Failure Analysis:&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Average cascade size: </span><span style="color:#f1fa8c">{</span>np<span style="color:#ff79c6">.</span>mean(cascade_sizes)<span style="color:#f1fa8c">:</span><span style="color:#f1fa8c">.1f</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Average cascade steps: </span><span style="color:#f1fa8c">{</span>np<span style="color:#ff79c6">.</span>mean(cascade_steps)<span style="color:#f1fa8c">:</span><span style="color:#f1fa8c">.1f</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Plot results</span>
</span></span><span style="display:flex;"><span>plot_resilience_analysis(G, analysis_results)
</span></span></code></pre></div><h2 id="key-takeaways">Key Takeaways<a hidden class="anchor" aria-hidden="true" href="#key-takeaways">#</a></h2>
<ol>
<li><strong>Robustness measures</strong>: Multiple ways to quantify network resilience</li>
<li><strong>Attack strategies</strong>: Random vs. targeted attacks have different effects</li>
<li><strong>Failure cascades</strong>: Understanding how failures propagate through networks</li>
<li><strong>Resilience enhancement</strong>: Strategies for improving network robustness</li>
<li><strong>Applications</strong>: Important for materials science and engineering</li>
<li><strong>Mathematical analysis</strong>: Rigorous theory for understanding resilience</li>
<li><strong>Practical implications</strong>: Design principles for robust networks</li>
</ol>
<h2 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h2>
<ol>
<li>Newman, M. E. J. (2010). Networks: An Introduction. Oxford University Press.</li>
<li>Albert, R., Jeong, H., &amp; Barabási, A. L. (2000). Error and attack tolerance of complex networks. Nature, 406(6794), 378-382.</li>
<li>Callaway, D. S., et al. (2000). Network robustness and fragility: percolation on random graphs. Physical Review Letters, 85(25), 5468.</li>
<li>Holme, P., et al. (2002). Attack vulnerability of complex networks. Physical Review E, 65(5), 056109.</li>
</ol>
<hr>
<p><em>Network resilience analysis provides crucial insights for understanding and improving the robustness of complex systems, with important applications in materials science and engineering.</em></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://Linlin-resh.github.io/tags/reading-notes/">Reading-Notes</a></li>
      <li><a href="https://Linlin-resh.github.io/tags/network-theory/">Network-Theory</a></li>
      <li><a href="https://Linlin-resh.github.io/tags/network-resilience/">Network-Resilience</a></li>
      <li><a href="https://Linlin-resh.github.io/tags/robustness/">Robustness</a></li>
      <li><a href="https://Linlin-resh.github.io/tags/failure-analysis/">Failure-Analysis</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience on x"
            href="https://x.com/intent/tweet/?text=Reading%20Notes%3a%20Newman%27s%20Networks%20Chapter%2016%20-%20Network%20Resilience&amp;url=https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f&amp;hashtags=reading-notes%2cnetwork-theory%2cnetwork-resilience%2crobustness%2cfailure-analysis">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f&amp;title=Reading%20Notes%3a%20Newman%27s%20Networks%20Chapter%2016%20-%20Network%20Resilience&amp;summary=Reading%20Notes%3a%20Newman%27s%20Networks%20Chapter%2016%20-%20Network%20Resilience&amp;source=https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f&title=Reading%20Notes%3a%20Newman%27s%20Networks%20Chapter%2016%20-%20Network%20Resilience">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience on whatsapp"
            href="https://api.whatsapp.com/send?text=Reading%20Notes%3a%20Newman%27s%20Networks%20Chapter%2016%20-%20Network%20Resilience%20-%20https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience on telegram"
            href="https://telegram.me/share/url?text=Reading%20Notes%3a%20Newman%27s%20Networks%20Chapter%2016%20-%20Network%20Resilience&amp;url=https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Reading Notes: Newman&#39;s Networks Chapter 16 - Network Resilience on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Reading%20Notes%3a%20Newman%27s%20Networks%20Chapter%2016%20-%20Network%20Resilience&u=https%3a%2f%2fLinlin-resh.github.io%2fposts%2freading-notes-newman-ch16%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://Linlin-resh.github.io/">Notes on AI4Science &amp; Graph Theory</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
