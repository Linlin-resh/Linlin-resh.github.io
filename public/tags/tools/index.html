<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tools | Notes on AI4Science & Graph Theory</title><meta name=keywords content><meta name=description content="Thoughts on Partially Disordered Networks, Silver Nanowires, Graph Theory, and Machine Learning"><meta name=author content="Linlin-resh"><link rel=canonical href=https://Linlin-resh.github.io/tags/tools/><link crossorigin=anonymous href=/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as=style><link rel=icon href=https://Linlin-resh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Linlin-resh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Linlin-resh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://Linlin-resh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://Linlin-resh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://Linlin-resh.github.io/tags/tools/index.xml><link rel=alternate hreflang=en href=https://Linlin-resh.github.io/tags/tools/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://Linlin-resh.github.io/tags/tools/"><meta property="og:site_name" content="Notes on AI4Science & Graph Theory"><meta property="og:title" content="Tools"><meta property="og:description" content="Thoughts on Partially Disordered Networks, Silver Nanowires, Graph Theory, and Machine Learning"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tools"><meta name=twitter:description content="Thoughts on Partially Disordered Networks, Silver Nanowires, Graph Theory, and Machine Learning"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Linlin-resh.github.io/ accesskey=h title="Notes on AI4Science & Graph Theory (Alt + H)">Notes on AI4Science & Graph Theory</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Linlin-resh.github.io/ title=Home><span>Home</span></a></li><li><a href=https://Linlin-resh.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://Linlin-resh.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://Linlin-resh.github.io/about/ title=About><span>About</span></a></li><li><a href=https://Linlin-resh.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Tools</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Structural Graph Theory Tools: Code Snippets for Materials Analysis</h2></header><div class=entry-content><p>Introduction This post provides practical code snippets for analyzing structural properties of graphs, particularly useful for materials science applications. These tools help identify structural motifs, quantify disorder, and analyze connectivity patterns.
Essential Graph Analysis Functions 1. Structural Motif Detection Triangle Counting import networkx as nx import numpy as np from collections import defaultdict def count_triangles_by_node(G): """Count triangles containing each node""" triangles = defaultdict(int) for node in G.nodes(): neighbors = list(G.neighbors(node)) for i in range(len(neighbors)): for j in range(i+1, len(neighbors)): if G.has_edge(neighbors[i], neighbors[j]): triangles[node] += 1 triangles[neighbors[i]] += 1 triangles[neighbors[j]] += 1 return dict(triangles) def clustering_coefficient_distribution(G): """Calculate clustering coefficient distribution""" clustering = nx.clustering(G) values = list(clustering.values()) return { 'mean': np.mean(values), 'std': np.std(values), 'min': np.min(values), 'max': np.max(values), 'distribution': values } Clique Detection def find_maximal_cliques(G, min_size=3): """Find maximal cliques of given minimum size""" cliques = [] for clique in nx.find_cliques(G): if len(clique) >= min_size: cliques.append(clique) return sorted(cliques, key=len, reverse=True) def clique_size_distribution(G): """Analyze distribution of clique sizes""" clique_sizes = [len(clique) for clique in nx.find_cliques(G)] if not clique_sizes: return {'counts': {}, 'total': 0} size_counts = defaultdict(int) for size in clique_sizes: size_counts[size] += 1 return { 'counts': dict(size_counts), 'total': len(clique_sizes), 'max_size': max(clique_sizes), 'avg_size': np.mean(clique_sizes) } 2. Disorder Quantification Local Order Parameters def calculate_local_order(G, reference_distances=None): """Calculate local order parameters for each node""" local_order = {} for node in G.nodes(): neighbors = list(G.neighbors(node)) if len(neighbors) &lt; 2: local_order[node] = 0.0 continue # Calculate actual distances actual_distances = [] for i in range(len(neighbors)): for j in range(i+1, len(neighbors)): if G.has_edge(neighbors[i], neighbors[j]): actual_distances.append(1.0) # Connected neighbors else: actual_distances.append(2.0) # Disconnected neighbors # Calculate reference distances (ideal ordered structure) if reference_distances is None: # Assume ideal structure has all neighbors connected reference_distances = [1.0] * len(actual_distances) # Calculate disorder as RMS deviation deviations = np.array(actual_distances) - np.array(reference_distances) local_order[node] = np.sqrt(np.mean(deviations**2)) return local_order def global_disorder_metric(G): """Calculate global disorder metric for the entire graph""" local_order = calculate_local_order(G) return np.mean(list(local_order.values())) Entropy-Based Disorder from scipy.stats import entropy def degree_entropy(G): """Calculate entropy of degree distribution as disorder measure""" degree_sequence = [d for n, d in G.degree()] degree_counts = defaultdict(int) for degree in degree_sequence: degree_counts[degree] += 1 # Normalize to get probabilities total_nodes = len(G.nodes()) probabilities = [count/total_nodes for count in degree_counts.values()] return entropy(probabilities) def structural_entropy(G, feature='clustering'): """Calculate structural entropy based on different features""" if feature == 'clustering': values = list(nx.clustering(G).values()) elif feature == 'betweenness': values = list(nx.betweenness_centrality(G).values()) elif feature == 'closeness': values = list(nx.closeness_centrality(G).values()) else: raise ValueError("Feature must be 'clustering', 'betweenness', or 'closeness'") # Bin the values for entropy calculation hist, _ = np.histogram(values, bins=20, density=True) hist = hist[hist > 0] # Remove zero bins return entropy(hist) 3. Connectivity Analysis Percolation Analysis def percolation_analysis(G, removal_fraction=0.1): """Analyze percolation behavior under random node removal""" n_nodes = len(G.nodes()) n_remove = int(n_nodes * removal_fraction) # Randomly remove nodes nodes_to_remove = np.random.choice(list(G.nodes()), n_remove, replace=False) G_temp = G.copy() G_temp.remove_nodes_from(nodes_to_remove) # Analyze connectivity components = list(nx.connected_components(G_temp)) largest_component = max(components, key=len) return { 'largest_component_size': len(largest_component), 'largest_component_fraction': len(largest_component) / n_nodes, 'num_components': len(components), 'nodes_removed': n_remove } def critical_threshold_estimation(G, trials=100): """Estimate critical threshold for percolation""" thresholds = np.linspace(0.1, 0.9, 20) results = [] for threshold in thresholds: component_sizes = [] for _ in range(trials): result = percolation_analysis(G, threshold) component_sizes.append(result['largest_component_fraction']) results.append({ 'threshold': threshold, 'mean_size': np.mean(component_sizes), 'std_size': np.std(component_sizes) }) return results 4. Visualization Tools Structural Motif Visualization import matplotlib.pyplot as plt def plot_triangle_distribution(G): """Plot distribution of triangles per node""" triangles = count_triangles_by_node(G) values = list(triangles.values()) plt.figure(figsize=(10, 6)) plt.hist(values, bins=20, alpha=0.7, edgecolor='black') plt.xlabel('Number of Triangles') plt.ylabel('Frequency') plt.title('Triangle Distribution') plt.grid(True, alpha=0.3) plt.show() return { 'mean': np.mean(values), 'median': np.median(values), 'std': np.std(values) } def plot_clustering_distribution(G): """Plot clustering coefficient distribution""" clustering = nx.clustering(G) values = list(clustering.values()) plt.figure(figsize=(10, 6)) plt.hist(values, bins=30, alpha=0.7, edgecolor='black') plt.xlabel('Clustering Coefficient') plt.ylabel('Frequency') plt.title('Clustering Coefficient Distribution') plt.grid(True, alpha=0.3) plt.show() return { 'mean': np.mean(values), 'median': np.median(values), 'std': np.std(values) } Complete Analysis Pipeline Materials Network Analyzer class MaterialsNetworkAnalyzer: """Comprehensive analyzer for materials networks""" def __init__(self, G): self.G = G self.results = {} def run_full_analysis(self): """Run complete structural analysis""" print("Running structural analysis...") # Basic properties self.results['basic'] = { 'nodes': self.G.number_of_nodes(), 'edges': self.G.number_of_edges(), 'density': nx.density(self.G), 'average_degree': np.mean([d for n, d in self.G.degree()]) } # Structural motifs self.results['triangles'] = count_triangles_by_node(self.G) self.results['clustering'] = clustering_coefficient_distribution(self.G) self.results['cliques'] = clique_size_distribution(self.G) # Disorder metrics self.results['local_order'] = calculate_local_order(self.G) self.results['global_disorder'] = global_disorder_metric(self.G) self.results['degree_entropy'] = degree_entropy(self.G) self.results['structural_entropy'] = structural_entropy(self.G) # Connectivity self.results['components'] = nx.number_connected_components(self.G) self.results['largest_component'] = len(max(nx.connected_components(self.G), key=len)) print("Analysis complete!") return self.results def generate_report(self): """Generate summary report""" if not self.results: print("Run analysis first!") return print("=== MATERIALS NETWORK ANALYSIS REPORT ===\n") # Basic statistics basic = self.results['basic'] print(f"Network Size: {basic['nodes']} nodes, {basic['edges']} edges") print(f"Density: {basic['density']:.4f}") print(f"Average Degree: {basic['average_degree']:.2f}") # Structural properties clustering = self.results['clustering'] print(f"\nClustering Coefficient: {clustering['mean']:.4f} ± {clustering['std']:.4f}") # Disorder metrics print(f"Global Disorder: {self.results['global_disorder']:.4f}") print(f"Degree Entropy: {self.results['degree_entropy']:.4f}") # Connectivity print(f"Connected Components: {self.results['components']}") print(f"Largest Component: {self.results['largest_component']} nodes") return self.results # Usage example if __name__ == "__main__": # Create example network G = nx.erdos_renyi_graph(100, 0.1) # Run analysis analyzer = MaterialsNetworkAnalyzer(G) results = analyzer.run_full_analysis() # Generate report analyzer.generate_report() Performance Tips Optimization Strategies Use NumPy arrays for large-scale computations Implement caching for repeated calculations Use sparse matrices for large networks Parallelize independent calculations Memory Management def memory_efficient_analysis(G): """Memory-efficient analysis for large networks""" # Process in batches batch_size = 1000 nodes = list(G.nodes()) results = [] for i in range(0, len(nodes), batch_size): batch_nodes = nodes[i:i+batch_size] batch_subgraph = G.subgraph(batch_nodes) # Analyze batch batch_results = analyze_subgraph(batch_subgraph) results.append(batch_results) # Clear memory del batch_subgraph return combine_batch_results(results) Conclusion These tools provide a foundation for structural analysis of materials networks. The key is to choose appropriate metrics based on your specific application and material system.
...</p></div><footer class=entry-footer><span title='2025-08-29 00:00:00 +0000 UTC'>August 29, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;925 words&nbsp;·&nbsp;Linlin-resh</footer><a class=entry-link aria-label="post link to Structural Graph Theory Tools: Code Snippets for Materials Analysis" href=https://Linlin-resh.github.io/posts/tool-snippets-structural-gt/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://Linlin-resh.github.io/>Notes on AI4Science & Graph Theory</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>